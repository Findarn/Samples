#include "baseunit.h"

//описание назначения функций - в baseunit.h. Также выводится при наведении курсора на имя функции

void wait_press_key(char *msg)
{
	fflush(stdin);		//очистка буфера ввода
	printf(msg);		//печать переданной в функцию строки *msg (например, "Нажмите любую клавишу")
	_getch();			//функция библиотеки windows.h. Ожидает ввода любого символа, но не выводит его на экран
}	

void WritelnString(char S[80])
{                
	printf("%s\n",S);					//Выводит строку S в консоль
	if (Device==1)						//Проверяется флаг Device - нужно ли выводить информацию в файл
		fprintf(fRes,"%s\n",S);			//Если нужно - дополнительно выводит строку S в файл
}	 

int Space(char *s, int k)
{ 
	int i=k, pos=-1;						//передаём в i позицию в строке, от которой начинаем поиск. Изначально позицию полагаем -1(неопределена)
	while(i<strlen(s) && s[i]!=' ')i++;		//функция strlen возвращает длину строки s. Условие звучит так - пока строка не закончилась и текущий символ не пробел - просматривать следующий символ
	if (i<strlen(s)) pos=i;					//Если i меньше длины строки, следовательно, в строке обнаружен пробел. i передается в pos - это позиция пробела в строке
	return pos;								//функция возвращает эту позицию
}	

int NotSpace(char *s, int k)
{ 
	int i=k, pos=-1;						//аналогично функции Space определяет позицию любого символа, не являющегося пробелом
	while(i<strlen(s) && s[i]==' ')i++;
	if (i<strlen(s)) pos=i;
	return pos;
}	

char *FillString(char *S, unsigned char len, unsigned char pk)
{
	unsigned char i,						//определяем итератор i для прохода по символам строки
			n=strlen(S);					//функция strlen определяет длину строки S и записывает её в переменную n
	char St[35]="";							//определяем пустую строку из 36 символов
	if (S[n-1]==' ') S[n-1]='\0';			//Проверяем последний символ строки на пробел. Если это пробел, заменяем его на \0 - в Си это идентификатор конца последовательности символов (NULL)
		if (n<len)							//Сравниваем длину строки с длиной len, до которой необходимо дополнить строку
	{										//Если она меньше (т.е. строку всё-таки необходимо дополнить), то:
		for (i=1; i<len-n; i++ )			//объявляем итерационный цикл. просматриваем символы от единицы до разницы между длиной строки и длиной дополнение (т.е. количество пробелов)
			if (pk==0)						//Если заполнить пробелами строку необходимо с левой стороны - записываем нужное количество пробелов в начало строки St
				strcat(St," ");				//записываем нужное количество пробелов в начало строки St
			else							//Если заполнить пробелами строку необходимо с правой стороны
				strcat(S," ");				//Дописываем к переданной строке S пробелы
	}
	if (pk==0)								//Если пробелы записывались справа, то заполненная строка уже готова и её можно возвращать
	{										//Иначе необходимо преобразовать строку St для вывода
		strcat(St,S);						//Функция strcat соединяет в цепочку строки St и S. Таким образом, к записанным слева пробелам добавляется сама строка
		strncpy(S,&St[0],strlen(St));		//Функция strncpy копирует первые strlen(St) символов из строки St в строку S. Этим завершается формирование строки S для выдачи
	}
	return S;								//Возврат строки S
}  

double GetNumber(double MinNumber, double MaxNumber, 
                   char m1,char n1,char m2,char n2)
{
	double Number;													//Переменная, используемая для вводимого числа
	unsigned char Cond=0;											//Флаг, который сообщает, успешно ли было введено число (1 - успешно, 0 - неудачно)
	char Format[80]="от %", s[10]="";								//Массивы символов (строки), используемые для вывода сообщений
	
	sprintf(s,"%d",m1);strcat(Format,s);strcat(Format,".");			//
	sprintf(s,"%d",n1);strcat(Format,s);strcat(Format,"f до %");	//Эти функции последовательно собирают строку Format для дальнейшего вывода
	sprintf(s,"%d",m2);strcat(Format,s);strcat(Format,".");			//функция sprintf отличается от обычной printf тем, что выводит написанное не в консоль, 
	sprintf(s,"%d",n2);strcat(Format,s);strcat(Format,"f.");		//а в заданную строку, здесь - в строку s. Затем с помощью strcat (см. выше) s добавляется к строке Format

  do																//организация цикла с постусловием (это значит, что тело цикла выполнится как минимум один раз в любом случае)
	{
		Cond=1;														//Предполагаем, что ввод будет успешным, заносим во флаг Cond единицу
		scanf("%lf",&Number);										//Вводим число с клавиатуры
		fflush(stdin);												//Очищаем буфер ввода
    if ((Number<MinNumber) || (Number>MaxNumber))					//Если число не помещается в заданный диапазон
		{		
			printf("Число должно быть в диапазоне ");				//Выводим сообщение об ошибке
      printf(Format, MinNumber,MaxNumber);							//Для этого используем собранную ранее строку Format, дополняя её минимальным и максимальным допустимыми значениями
      printf("\nПовторите ввод\n");									//Приглашение к повторному вводу
      Cond=0;														//Обнуляем Cond, так как ввод был совершён некорректно
		}
	}
	while (Cond==0);												//Постусловие цикла проверяет флаг Cond. Если он равен 0, повторяет тело цикла, пока ввод не будет совершён корректно.
  return Number;													//Возвращает введённое число в формате double
}	

void UsesDevice()
{          
  printf("Укажите устройство для вывода результатов: \n");			//выводим текстовое сообщение с приглашением ко вводу
  printf("   0 - только экран\n");
  printf("   1 - экран и текстовый файл\n");
	
	Device=(int)ceil(GetNumber(0,1,1,0,1,0));						//используем вышеописанную функцию для ввода числа от 0 до 1. При этом используем приведение типов:
																	//оригинальное введенное число в формате double, но нам необходим int. Функция ceil округляет значения типа double в большую сторону
																	//отбрасывая дробную часть. запись (int) осуществляет приведение типа double к типу int
}	 

int SearchKodif(int Kod, int nk)
{ 
	int  i1,i2,m;						//объявляем два индекса i1, i2, а также индекс m
	int SearchKod=-1;					//позиция искомой записи в кодификаторе. изначально -1 (неопределена)
	i1=0; i2=nk-1;						//i1 - индекс первого элемента массива кодификаторов, i2 - индекс последнего
  while (i1<=i2)						//организация цикла с предусловием - пока i1 не станет равным i2
	{
    m=(i1+i2)/2;						//вычисляем средний элемент в массиве и записываем его индекс в m
    if (Kod==Kodifs[m].Code)			//проверяем, является ли этот элемент искомым по его коду
		{
			SearchKod=m; break;			//если является, то позиция передается в SearchKod, выполнение цикла прерывается оператором break
		}
    else								//иначе
      if (Kod>Kodifs[m].Code)			//Если искомый код больше, чем средний
        i1=m+1;							//наращиваем i1 до m+1 - т.е. просматриваем только одну половину массива
      else								//иначе (если искомый код меньше чем средний)
        i2=m-1;							//уменьшаем i2 до m-1 - т.е. просматриваем другую половину массива
	}									
	return SearchKod;					//возвращаем позицию элемента с нужным кодом
}	 

void SortKodif(int nk)
{ 
  unsigned char i,j;								//объявляем два индекса i, j  							
  for (i=0; i<nk; i++)								//объявляем внешний цикл
	{
		for (j=i+1; j<nk; j++)						//объявляем внутренний цикл, отталкиваясь от индекса в текущем внешнем.
													//это существенно сокращает количество итераций в цикле.
			if (Kodifs[i].Code > Kodifs[j].Code)	//сравниваем значения по индексу i и j
			{
				Kodif=Kodifs[i];
				Kodifs[i]=Kodifs[j];				//если i-ое значение больше j-ого, осуществляем обмен записей кодификатора через буферную переменную Kodif
				Kodifs[j]=Kodif;					//таким образом, наибольшее значение оказывается на ппоследней позиции, а наименьшее - на первой (сортировка по возрастанию)
			}
		}
}	

int ReadFileOut(int *np, DynDirectory **Lp, DynDirectory **Rp)
{            
	DirectoryType Directory;											//определяем переменную структуры записи в архиве
	DynDirectory *Run;													//определяем указатель на текущий элемент очереди			 
	int p;																//переменная, с помощью которой будет определяться конец файла
	if (SignArchive==0)													//проверяем флаг создания архива
	{
		 printf("\nАрхив не создан. Режим отменяется.\n");
		 wait_press_key("\nДля продолжения нажмите любую клавишу\n");	//если архив не создан - выходим из функции, возвращая единицу - прочитать архив не удалось, т.к. его нет
		 return 1;
	}
	if((fArBin=fopen(fArBinName,"rb"))==NULL)							//в условном операторе помещаем функцию fopen, которая открывает файл fArBinName в режиме rb - бинарного чтения
																		//функция fopen при успешном открытии файла возвращает указатель на файл. Если файл не был открыт - возвращает NULL
																		//Такой записью файл одновременно открывается и тут же проверяется, был ли он открыт.
	{	
		printf("\nФайл %s не найден. Режим отменяется.\n",fArBinName);
		wait_press_key("\nДля продолжения нажмите любую клавишу\n");	//Если файл невозможно открыть, завершаем работу функции, и возвращаем единицу.
		SignArchive=0;
		return 1;
	}
  *np=0;																	//количество прочитанных записей
  *Lp = NULL; *Rp=NULL;														//указатели на левый и правый конец очереди изначально ни на что не указывают
	
 	if( p=fread(&Directory,sizeof(DirectoryType),1,fArBin)<1) p=EOF;		//ранее в операторе if открывался файл, теперь в нём производится чтение посредством функции fread
																			//в данном случае функция fread считывает в Directory из fArBin 1 объект размером sizeof(DirectoryType)
																			//функция возвращает количество реально считанных объектов. Так как за один раз мы считываем один объект,
																			//в случае успеха функция вернет 1. Если она вернет меньшее количество, значит мы достигли конца файла (EOF)
  while (p!=EOF)															//Объявляем цикл с предусловием - "пока не достигнем конца файла"
	{	
		Run= (DynDirectory *)malloc(sizeof(DynDirectory));					//Элемент был успешно прочитан. Необходимо выделить для него динамическую память. Это делается с помощью функции malloc
																			//Run - это указатель. После выделения памяти, в Run окажется ссылка(указатель) на первый байт области памяти, которая будет выделена
																			//функция malloc не имеет типа, поэтому её необходимо вручную привести к типу нужного указателя. Run - это DynDirectory*
																			//следовательно, приводим malloc к этому типу - (DynDirectory *)malloc. параметр, передаваемый в функцию - это количество байт,
																			//которые необходимо выделить. их можно записать вручную, а можно воспользоваться функцией sizeof(), которая возвращает объём, занимаемый 
																			//типом (пользовательским или базовым) в памяти.
		(*np)++;															//Инкрементируем количество элементов в очереди
		Run->Inf=Directory;													//Содержимое файла было записано в переменную Directory. Заносим его в информационное поле текущего элемента очереди      
		if (*Lp==NULL)														//Если указатель на левый крайний элемент списка был равен нулю (т.е. это первый включаемый в очередь элемент)
			{Run->Next=NULL;												//Указатель на следующий элемент ни на что не указывает (т.к. элемент в списке пока один)
			 *Lp = Run;													
			 *Rp = Run;
	  }
	  else																	//иначе (если элемент не единственный в списке)
	  {Run->Next = NULL;													//указатель на следующий элемент ни на что не указывает
	  (*Rp)->Next = Run;													//указатель элемента, который был крайним правым, переводим на текущий элемент вместо указателя на NULL
	  *Rp = Run;}															//текущий элемент полагаем крайним правым. Таким образом добавление в очередь производится с правой стороны
		if( p=fread(&Directory,sizeof(DirectoryType),1,fArBin)<1) p=EOF;	//осуществляем попытку снова прочитать файл
	}
  fclose(fArBin);															//После завершения чтения закрываем бинарный файл.
	return 0;																//Возвращаем ноль при успешном завершении работы
}	 

int WriteFileOut(DynDirectory *Lp,DynDirectory*Rp)
{           
	DirectoryType Directory;													//определяем переменную структуры записи в архиве
	DynDirectory*Run;															//определяем указатель на текущий элемент очереди
	if((fArBin=fopen(fArBinName,"wb"))==NULL)									//как и ранее, открываем файл одновременно с проверкой успешности его открытия. в этот раз открываем в режиме wb
																				//wb - бинарная запись
		{
		 printf("\nФайл %s не создан\n",fArBinName);
		 wait_press_key("\nДля завершения программы нажмите любую клавишу\n");	//Если открыть файл не удалось - завершаем работу функции с соответствующим сообщением.
		 exit(0);
		}
  Run=Lp;																		//Если файл открыт, устанавливаем указатель текущего элемента очереди на крайний левый элемент очереди
  while ( Run != NULL)															//организовываем цикл с предусловием - пока текущий элемент не укажет на NULL
	{	
		Directory=Run->Inf;														//Передаем в Directory содержимое информационного поля текущего элемента
		fwrite(&Directory,sizeof(DirectoryType),1,fArBin);						//осуществляем запись в файл с помощью функции fwrite - записываем в файл dArBin 1 объект размером sizeof(DirectoryType)
																				//из поля Directory
		Run=Run->Next;															//Переводим указатель на текущий элемент очереди на следующий элемент
	} 
  fclose(fArBin);																//После работы с файлом закрываем его
  DisposeDirectory(Lp,Rp);														//Удаляем очередь, т.к. все данные перенесены в файл.
	return 0;																	//возвращаем ноль как результат корректного завершения работы функции
}	

void DisposeDirectory(DynDirectory *Lp, DynDirectory *Rp)
{            
	DynDirectory*Run;	//создаем указатель на текущий элемент очереди		 
  while (Lp != NULL)	//цикл с предусловием - пока указатель на левый крайний элемент не указывает на NULL
  {
		Run=Lp;			//Крайний левый элемент помечаем как текущий
		Lp=Lp->Next;	//сдвигаем крайний левый элемент
		free(Run);		//освобождаем память от текущего
	}					
}	 

int clear_input_buffer()
{
	int ch;													//объявляем переменную в которую будем заносить текущий буфер ввода
	while (((ch = getchar()) != EOF) && (ch != '\n')) ;		//производится считывание оставшихся в буфере символов переноса строки 
	return ch;												//после чего она изымается из буфера и возвращается через ch
}
