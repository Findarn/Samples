#include "AddArchiv.h"

int AddArchive()
{                      
	DirectoryType Directory;
	DynDirectory*Run;			//определяем указатель на элемент очереди, который будет использоваться как индекс текущего элемента
	DynDirectory*Lp,*Rp;		//определяем указатели на элемент очереди, которые будут использоваться как индекс крайнего левого и крайнего правого элементов очереди
	unsigned char Cond;		
	int Sr, np;					
	if (SignArchive==0)													//проверяем, создан ли архив
	{
		 printf("\nАрхив не создан. Режим отменяется.\n");
		 wait_press_key("\nДля продолжения нажмите любую клавишу\n");	//если не создан - печатаем сообщение об ошибке
		 return 1; 
	}
	
	 if((fAddTxt=fopen(fAddTxtName,"rt"))==NULL)						//открываем файл add в режиме чтения текстового файла rt
	{
		 printf("\nФайл %s не найден.Режим отменяется.\n",fAddTxtName);
		 wait_press_key("\nДля продолжения нажмите любую клавишу\n");	//если открыть файл не удалось - печатаем сообщение об ошибке, сбрасываем флаг создания архива
		 SignArchive=0;
		 return 1;
	}
	if ( ReadFileOut(&np,&Lp,&Rp) == 1)				//считываем бинарный файл архива и формируем очередь. Если сделать это не удалось (функция вернула единицу) 
			{fclose(fAddTxt); return 1;}			//закрываем текстовый файл и выходим из функции
	do
	{  
		if (ReadDirectory(fAddTxt, &Directory)==0)	//считываем строку из текстового файла в Directory, формируем структуру
		{	
			Sr= Directory.Code;			//заносим в Sr значение кода из прочитанной строки файла add
			Run=Lp;						//устанавливаем Run на Lp
			Cond=0;						//обнуляем флаг Cond, который сообщает о том, есть ли уже изделие с таким кодом в бинарном архиве
      while (Run!=NULL)					//пока не пройдем всю очередь
			{
				if (Run->Inf.Code==Sr)	//если находим совпадающие коды
					{ Cond=1; break;}	//флаг Cond устанавливаем в 1, прерываем проход по очереди
        Run=Run->Next;					//перемещается к следующему элементу очереди
			}
      if (Cond == 0 )					//если код изделия не совпадает ни с одним в очереди
			{	
  			Run=(DynDirectory*)malloc(sizeof(DynDirectory));	//выделяем динамическую память для нового элемента в очереди
				Run->Inf= Directory;			
				Run->Next=NULL;									//и помещаем его в конец динамического списка
				Rp->Next = Run;									//используя указатель на крайний правый элемент очереди
				Rp = Run;
			}
      else														//если найден повторяющийся код
        printf("\nВ архиве уже есть изделие с кодом %6d",Sr);	//он не добавляется в очередь, и об этом печатается сообщение
		}
	}
	while ( ! feof(fAddTxt) );									//считывание строк из файла add происходит до тех пор, пока не обнаружится конец файла
	fclose(fAddTxt);											//после окончания работы файл add закрывается
    WriteFileOut(Lp,Rp);										//бинарный файл архива перезаписывается новой сформированной очередью
	DisposeDirectory(Lp, Rp);									//удаляем очередь
    FlagAdd = 1;												//устанавливаем флаг дополнения архива - теперь архив дополнен
    FlagSort = 0;												//сбрасываем флаг сортировки - в конце архива теперь несортированные данные
    printf("\nДополнение архива закончено\n");
	wait_press_key("\nДля продолжения нажмите любую клавишу\n");
	return 0;
}	
