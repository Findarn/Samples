#include "DeleteArchiv.h"

int DeleteArchive()
{											
int Kod,KodPr, pos = -1;
unsigned char Cond;
DynDirectory*Lp,*Rp;	//определяем указатели на элементы очереди, которые будут использоваться как индексы крайнего левого и крайнего правого элементов очереди
DynDirectory*Del;		//определяем указатель на элемент очереди, который будет использоваться как индекс удаляемого элемента
DynDirectory*Run;		//определяем указатель на элемент очереди, который будет использоваться как индекс текущего элемента
int np;
char Sr[80]="";
  if ( ! SignArchive )													//проверяем, создан ли архив
	{
		 printf("\nАрхив не создан. Режим отменяется.\n");
		 wait_press_key("\nДля продолжения нажмите любую клавишу\n");
		 return 1;
	}
  ReadFileOut(&np,&Lp,&Rp);							//считываем бинарный файл архива и формирует очередь структур
  
	printf("\nУкажите код удаляемого ФИО : ");		//приглашение ко вводу кода удаляемой записи
  Kod=(int)ceil(GetNumber(0,99999,1,0,5,0));		//приём кода удаляемой записи с клавиатуры с заданным диапазоном
	Cond=0; KodPr=Kod;								//обнуляем флаг Cond, который будет сообщать о том, производилось ли удаление
  
	if ( Kod == Lp->Inf.Code)			//если искомый код соответсвует коду самого первого элемента
	{		 
		Cond=1;							//флаг Cond полагаем равным единице - удаляемый элемент найден
		Del=Lp; Lp=Lp->Next;			//указатель Del помещаем на Lp, сам Lp переводим на следующий элемент
		free(Del);						//освобождаем память по указателю Del, таким образом удаляя элемент
	}
  else
	{
		Run=Lp;									//устанавливаем Run на Lp
    while ( Run->Next != NULL )					//проходим всю очередь стркуткр
    {		
      if ( Kod == Run->Next->Inf.Code )			//сравниваем введённый код с кодом следующего после Run элемента
			{	
				Cond=1;							//если код найден, устанавливаем флаг Cond
				Del=Run->Next;					//устанавливаем указатель Del на удаляемый элемент
				if (Run->Next == Rp )			//если удаляемый элемент - крайний правый
					{Rp=Run; Rp->Next=NULL;}	//то новый крайний правый - это текущий, а его указатель на следующий элемент указывает на NULL
				else	
					{Run->Next=Del->Next; }		//иначе перестраиваем цепочку связей между элементами до удаления Del
				free(Del);						//освобождаем память по указателю Del, тем самым удаляя элемент
				break;							//т.к. элемент был найден и удален, прерываем выполнение цикла
			}
			Run=Run->Next;						//осуществляем переход к следующему элементу очереди
		}
	}
  if( Cond == 1 )											//если удаление происходило
  { 
		for (int i = 0; i < nk; i++)						//определяем позицию кода удаленного элемента в масиве кодификаторов
			{
			if (KodPr == Kodifs[i].Code)
				{
				pos = i; break;								//передаем позицию в переменную pos
				}
			}
		for (int i = pos; i < nk; i++)						//относительно переменной pos до конца массива
		{
			Kodifs[i] = Kodifs[i + 1];			//сдвигаем все элементы влево
												//удаляя таким образом нужный код из массива кодификатора
		}
		nk--;													//уменьшаем количество элементов в кодификаторе
		np--;													//уменьшаем количество элементов в архиве
		WriteFileOut(Lp,Rp);									//перезаписываем бинарный файл архива
		printf("\nУдаление компонента из архива закончено");
	}
  else						
	printf("\nВ архиве нет компонента с кодом %6d",KodPr);			//если удаления не происходило
  wait_press_key("\nДля продолжения нажмите любую клавишу\n");	//выводим об этом сообщение
	DisposeDirectory(Lp, Rp);                   //удаляем очередь
	return 0;
}  
