#include "CheckInpFile.h"

void CheckFiles()
{							
	DirectoryArPtr   Directories, AddDirectories;						//определяем указатели на массив структур для файлов input и add
	if((FileError=fopen(FileErrorName,"wb+"))==NULL)					//открываем файл ошибок в режиме бинарной дозаписи wk+
		{	
		 printf("\nФайл %s не найден\n",FileErrorName);
		 wait_press_key("\nДля завершения нажмите любую клавишу\n");
		 exit(0);
		}	
	sprintf(Sr,"\n         ПРОТОКОЛ КОНТРОЛЯ ТЕКСТОВЫХ ФАЙЛОВ\n");		//записываем в строку Sr сообщение
	fwrite(Sr,sizeof(string80),1,FileError);							//записываем строку Sr в файл
    FatalError=0;														//флаг ошибки устанавливаем в 0
	Sf=(FileStringAr *)malloc(sizeof(FileStringAr));					//выделяем память для динамического массива строк текстового файла
	
    Directories=(DirectoryAr *)malloc(sizeof(DirectoryAr));				//выделяем память для массива структур файла input
	AddDirectories=(DirectoryAr *)malloc(sizeof(DirectoryAr));			//выделяем память для массива структур файла add
	FormatFileDirectory(fArTxt,fArTxtName,&np,NfMax, Directories);		//вызываем функцию проверки формата для файла input
	FormatFileDirectory(fAddTxt,fAddTxtName,&nd,NfMax, AddDirectories);	//вызываем функцию проверки формата для файла add
	
  FormatFileKodif();													//вызываем функцию проверки формата файла кодификатора kodif
  
  if (FatalError==0)										//если при предыдущих проверках не обнаружены ошибки
	{	
		CheckDireDiapason(fArTxtName,np, Directories);		//проверяем строки файла input на соответствие диапазонов
		CheckDireDiapason(fAddTxtName,nd,AddDirectories);	//проверяем строки файла add на соответствие диапазонов
		CheckKodifDiapason();								//проверяем строки файла kodif на соответствие диапазонов
	}

  if (! FatalError)										//если при предыдущих проверках не обнаружены ошибки
	{	
		KodifParameters();								//проверяем, не дублируются ли коды в кодификаторе
		SortKodif(nk);									//сортируем кодификатор
		DireParameters(Directories,np,fArTxtName);		//проверяем, не дублируются ли коды в файле input, и есть ли соответствующие коды в кодификаторе kodif
		DireParameters(AddDirectories,nd,fAddTxtName);	//проверяем, не дублируются ли коды в файле add, и есть ли соответствующие коды в кодификаторе kodif
    
	}
	if (FatalError)												//если ошибки были обнаружены
    sprintf(Sr,"\nСкорректируйте исходные файлы\n");			//записываем в строку Sr сообщение об ошибках
  else															//иначе (если ошибок не обнаружено)
    sprintf(Sr,"\nВ исходных файлах ошибок не обнаружено\n");	//записываем в строку Sr сообщение об отсутствии ошибок
	fwrite(Sr,sizeof(string80),1,FileError);					//печатаем строку Sr в файл ошибок
	ReadFileError();											//считываем файл ошибок и выводим его на экран. 
	free(Sf); Sf=NULL;											//освобождаем память и обнуляем указатели на динамические массивы
    free(Directories);    Directories=NULL;
    free(AddDirectories); AddDirectories=NULL;
    fclose(FileError);											//закрываем файл ошибок
} 

void FormatFileDirectory(FILE *F, char *FileName, int *nf,
                           int Nmax, DirectoryAr *Dire)
{       
	DirectoryType Directory;							 
	char  k,k1,k2,n,Cond;								
	int  i,Code;
	string80 Sa,Sb;
	ReadAndCheckSpaces(F,FileName,nf,Nmax);						//проверяем возможность чтения файла, проверяем на допустимое количество строк, удаляем пустые строки		
  if (FatalError) return;										//если при проверке возникли ошибки, выходим из функции
  for (i=0; i<(*nf); i++)										//организовываем цикл перебора строк. i в данном цикле будет указывать на номер строки
	{
		strcpy(Sa,(*Sf)[i]);				//копируем i-ую строку из файла в строку Sa	
		k=strlen(Sa);						//определяем длину строки Sa и записываем 	
		if (Sa[k-1]==10) Sa[k-1]='\0';		//если последний символ строки это 10 (перевод на следующую строку), заменяем его "\0" - признак конца строки
    Cond=1; k2=-1; k=0;						//устанавливаем флаги Cond, k2, k. k - это номер слова в текущей строке
    while (Cond)							//организовываем цикл с предусловием (пока Cond != 0)	
		{
		k1=NotSpace(Sa,k2+1);				//В k1 записываем индекс первого символа, не являющегося пробелом
		if (k1==-1)							//если такого символа нет (вся строка состоит из пробелов)
        Cond=0;								//обнуляем флаг Cond
	  else
	  {
		  k2 = Space(Sa, k1 + 1);										//в k2 записываем индекс первого символа, являющегося пробелом
		  if (k2 == -1)													//если такого символа не (в строке нет пробелов)
		  { k2 = strlen(Sa) + 1;										//в k2 заносится длина строки Sa + 1
			Cond = 0; }													//флаг Cond сбрасываем в ноль
		  k++;															//Если чтение было успешным, увеличиваем количество прочитанных слов
																		//Слово здесь - это подстрока (часть строки) в строке, которое ограничено пробелами/символами окончания строки
		  if (k > 7)													//если в течение цикла количество подсчитанных слов окажется больше семи
		  {
			  FatalError = 1;
			  sprintf(Sr, "Файл %s : в строке %d свыше 7 элементов\n",	//выводим сообщение об ошибки и записываем его в файл
				  FileName, i + 1);			  
			  fwrite(Sr, sizeof(string80), 1, FileError);
		  }
		  n = k2 - k1;													//в k2 находится индекс пробельного символа, в k1 - индекс непробельного символа.
																		//вычитая k2-k1 получим длину слова
		  strncpy(Sb, &Sa[k1], n);										//копируем n символов из строки Sa начиная с индекса k1 в строку Sb
		  Sb[n] = '\0';													//в конце строки Sb добавляем признак окончания строки           
		  switch (k)													//каждое слово проверяется на соответствие своему формату
		  {	
		  case 1:
			  if (strlen(Sb) > 6)																				//проверяем первое слово - это номер записи в журнале - 2 буквы и 4 цифры
			  {																									//так как формат записи - char, организовать полноценную проверку и ввести
				  FatalError = 1;																				//проверку диапазона чисел довольно трудно, и требует множественного приведения типов
				  sprintf(Sr, "Файл %s : в строке %d  длина элемента 1 свыше 6 символов\n", FileName, i + 1);	//поэтому char-поля будем проверять на соответствие длине - в данном случае 6 символов
				  fwrite(Sr, sizeof(string80), 1, FileError);													//если прочитанное слово длиннее 6 символов - сообщаем об ошибке, указывая строку и номер слова
			  }
			  strncpy(Directory.Num, &Sb[0], n);																//если прочитанное слово удовлетворяет длине, копируем n символов из строки Sb в соответствующее поле структуры
			  Directory.Num[n] = '\0';																			//крайний символ помечаем как признак окончания строки
			  FillString(Directory.Num, 6, 1);						break;										//для того, чтобы все записи сделать типовыми, заполняем оставшееся в строке свободное место пробелами справа
		  case 2:Code = sscanf_s(Sb, "%d", &Directory.Code);														//проверяем второе слово - это код фамилии и инициалов. функция sscanf идентичная scanf
			  if (Code < 1)																							//но вместо стандартного ввода с клавиатуры принимает информацию из указанного источника	
			  {	  FatalError = 1;																					//в данном случае - из строки Sb. Она возвращает количество полей, которым удалось присвоить значения
				  sprintf(Sr, "Файл %s : в строке %d неправильный формат элемента 1 (%s)\n", FileName, i + 1, Sb);	//т.е. в успешном случае она вернёт 1. Если же она вернёт меньшее значение - это признак ошибки
				  fwrite(Sr, sizeof(string80), 1, FileError);														//о которой выводится сообщение. Значение кода сразу заносится в поле структуры Code.
			  }														break;
		  case 3:Code = sscanf_s(Sb, "%d", &Directory.Birthday);													//проверяем третье слово - дату рождения
			  if (Code < 1)																							//проверка идентична case 2
			  {
				  FatalError = 1;
				  sprintf(Sr, "Файл %s : в строке %d неправильный формат элемента 1 (%s)\n", FileName, i + 1, Sb);
				  fwrite(Sr, sizeof(string80), 1, FileError);
			  }														break;
		  case 4:																								//проверяем четвертое слово - улицу. Это снова строка, для которой предусмотрено 15 символов
			  if (strlen(Sb) > 15)																				//проверка идентична case 1, отличие только в длине полей
			  {
				  FatalError = 1;
				  sprintf(Sr, "Файл %s : в строке %d  длина элемента 1 свыше 15 символов\n", FileName, i + 1);
				  fwrite(Sr, sizeof(string80), 1, FileError);
			  }
			  strncpy(Directory.Street, &Sb[0], n);
			  Directory.Street[n] = '\0';
			  FillString(Directory.Street, 15, 1);						break;
		  case 5:Code = sscanf_s(Sb, "%d", &Directory.House);												//проверяем пятое слово - номер дома
			  if (Code < 1)																					//проверка идентична case 2, 3
			  {
				  FatalError = 1;
				  sprintf(Sr,
					  "Файл %s : в строке %d неправильный формат элемента 1 (%s)\n", FileName, i + 1, Sb);
				  fwrite(Sr, sizeof(string80), 1, FileError);
			  }														break;
		  case 6:Code = sscanf_s(Sb, "%d", &Directory.Flat);												//проверяем шестое слово - номер квартиры
			  if (Code < 1)																					//проверка идентична case 2, 3, 5
			  {
				  FatalError = 1;
				  sprintf(Sr,
					  "Файл %s : в строке %d неправильный формат элемента 1 (%s)\n", FileName, i + 1, Sb);
				  fwrite(Sr, sizeof(string80), 1, FileError);
			  }														break;
		  case 7:Code = sscanf_s(Sb, "%d", &Directory.Phone);												//проверяем седьмое слово - номер телефона
			  if (Code < 1)																					//проверка идентична case 2, 3, 5, 6
			  {
				  FatalError = 1;
				  sprintf(Sr,
					  "Файл %s : в строке %d неправильный формат элемента 1 (%s)\n", FileName, i + 1, Sb);
				  fwrite(Sr, sizeof(string80), 1, FileError);
			  }														break;

		  }
	  }
        
		}
    if (k<7)																	//после того, как закончили читать строку, анализируем количество прочитанных слов
		{																		//внутри цикла находится проверка на число, превышающее семь слов, здесь - проверка на меньшее число слов
      FatalError=1;
      sprintf(Sr, "Файл %s : в строке %d меньше 7 элементов\n",FileName,i+1);	//если слов меньше семи - печатаем сообщение об ошибке		
      fwrite(Sr,sizeof(string80),1,FileError);
		}
    (*Dire)[i]=Directory;														//Dire - массив указателей на структуры типа Directory, которые формируются в процессе чтения файлов
	}																			//На текущем шаге цикла записываем текущий сформированный элемент в i-ую запись
}   

void  FormatFileKodif()
{              
	char k,k1,k2,n,Cond;
	int i, Code;
  string80 Sa,Sb,S1;
	ReadAndCheckSpaces(fKodif,fKodifName,&nk,NfMax);						//в предыдущей функции производилось чтение записей из файлов input и add 
  if (FatalError) return;													//в это функции читаются записи кодификатора
  for (i=0; i<nk; i++)														//способ чтения - определение индексов пробельных и непробельных символов - точно такой же
	{	
		strcpy(Sa,(*Sf)[i]);
 		k=strlen(Sa);				
		if (Sa[k-1]==10) Sa[k-1]='\0';
		Cond=1; k2=-1; k=0;
    while (Cond)
		{
			k1=NotSpace(Sa,k2+1); 
			if (k1==-1)
				Cond=0;
			else
			{
				k2=Space(Sa,k1+1);	
				if (k2==-1)
				{
					k2=strlen(Sa)+1;
					Cond=0;
				}
				k++;
				if (k>2) 
				{
					FatalError=1;
					sprintf(Sr,	"Файл Kodif.txt : в строке %d свыше 2 элементов\n",i+1);	//в кодификаторе ожидаем встретить всего два слова в строке - код ФИО и непосредственно ФИО
					fwrite(Sr,sizeof(string80),1,FileError);
				}
				n=k2-k1;							
				strncpy(Sb,&Sa[k1],n);
				Sb[n]='\0';          
				 switch (k)
				{
					case 1:Code=sscanf_s(Sb,"%d",&Kodif.Code);																//проверяем первое слово - это целочисленное значение
						if (Code<1)
							{
								FatalError=1;
								sprintf(Sr,	"Файл Kodif.txt : в строке %d неправильный формат элемента 1 (%s)\n", i+1,Sb);
								fwrite(Sr,sizeof(string80),1,FileError);
							}																						break;
					case 2:																									//проверяем второе слово - это строка из 25 символов
						if (strlen(Sb)>20) 
							{ 
								FatalError=1;
								sprintf(Sr, "Файл Kodif.txt : в строке %d длина элемента 2 свыше 20 символов\n", i+1);
								fwrite(Sr,sizeof(string80),1,FileError);
							}
							strncpy(Kodif.FIO,&Sb[0],n);    
							Kodif.FIO[n]=' ';
							Kodif.FIO[n+1]='\0'; break;          
				}
			}
		}
    if (k<2)																//проверяем на меньшее количество слов
		{	
      FatalError=1;
			sprintf(Sr,
			"Файл Kodif.txt : в строке %d меньше 2 элементов\n",i+1);
      fwrite(Sr,sizeof(string80),1,FileError);
		}    
    Kodifs[i]=Kodif;						//для кодификатора используем простой массив - в i-ый элемент массива заносим сформированную структуру
	}
}   

void ReadAndCheckSpaces(FILE *F, char *FileName, int *nf, int Nmax)
{
	char  i,j,k;													
	char  SignSpace;   
	string80 sw;

	if((F=fopen(FileName,"rt"))==NULL)								//открываем файл в режиме чтения текстового файла rt и проверяем успешность его открытия
		{
		 sprintf(Sr,"Отсутствует исходный файл %s\n",FileName);
		 FatalError=1;												//в случае неудачи печатаем сообщение об ошибке
		 fwrite(Sr,sizeof(string80),1,FileError);
		 return;
		}
  *nf=0;															//переменная, определяющая количество строк в файле			
  while (fgets(sw,80,F)!=NULL)										//функция fgets считывает до 80 символов из файла F и помещает их в массив символов sw. считывание происходит до тех пор, пока
	{																//не встретится символ "новая строка", конец файла либо не достигнется предел в 80 символов. также проверяется исход считывания
		if ((*nf)<PMax)												//если при считывании функция вернула NULL - считывать уже нечего
			strcpy((*Sf)[*nf],sw);		//если номер текущей строки не превышает максимального заданного, то текущая считанная строка копируется в nf-ый элемент массива строк
			(*nf)++;					//увеличиваем количество прочитанных строк в файле
	}
  fclose(F);		//после работы с файлом закрываем его

  if (*nf==0)												//если прочитанное количество строк равно нулю
	{
     FatalError=1;
     sprintf(Sr,"Исходный файл  %s   пустой\n",FileName);	//устанавливаем флаг ошибки, печатаем сообщение об ошибке
		 fwrite(Sr,sizeof(string80),1,FileError);
     return;
	}

  if (*nf>NfMax)													//если количество прочитанных строк больше заданного максимума строк
	{
      FatalError=1;
			sprintf(Sr,
				"В исходном файле  %s  свыше  %d  строк (%d)\n",	//устанавливаем флаг ошибки, печатаем сообщение об ошибке
				FileName,NfMax,*nf);
			fwrite(Sr,sizeof(string80),1,FileError);
      return;
	}

  SignSpace=0;									//флаг, показывающий наличие пустых строк
  i=0;
  while (i<(*nf))								//цикл с предусловием от i=0 до количества прочитанных строк в файле
	{
      k=NotSpace((*Sf)[i],0);					//в k помещаем индекс первого непробельного элемента
      if ((k==-1) || ((*Sf)[i][k]==10))			//если непробельного элемента в строке нет, либо непробельный элемент это символ окончания строки - то строка пустая, т.е. состоит из пробелов
			{	
          for (j=i; j<(*nf)-1; j++)				//организовываем цикл - просматриваем строки от текущей до максимального размера, уменьшенного на один
            strcpy((*Sf)[j],(*Sf)[j+1]);		//заменяем попарно строки, исключая ту, которая была пустой
          (*nf)--;								//уменьшаем итоговое количество строк в файле
          SignSpace=1;							//взводим флаг найденной пустой строки - все операции пока выполняются над массивом строк, а не над файлом. Впоследствии файл нужно будет перезаписать
			}
      else
        i++;									//наращиваем индекс текущей строки
	}
  if (SignSpace)								//если пустые строки были обнаружены и удалены в массиве строк файла
	{	
		if((F=fopen(FileName,"wt"))==NULL)								//открываем файл в режиме записи текстового файла wt - вся бывшая в нем информация удаляется
		{
		 sprintf(Sr,
			 "Не удалось создать файл %s для удаления пустых строк\n",
			 FileName);													//если не удалось открыть файл, печатаем сообщение об ошибке
		 FatalError=1;
		 fwrite(Sr,sizeof(string80),1,FileError);
		 return;
		}
    for (i=0; i<(*nf);i++)							//организовываем цикл от i=0 до количества строк в файле (без пустых строк)
		 fputs((*Sf)[i],F);							//записываем построчно каждую строку в файл
    fclose(F);										//закрываем файл после работы с ним
	}

} 

void CheckDireDiapason(char *FileName, int nf, DirectoryAr *Dire)
{          
int i;
  for (i=0; i<nf; i++)																	//проверяем массив значений структуры на соответствие численным параметрами
	{
    if (((*Dire)[i].Code<0) || ((*Dire)[i].Code>99999))							//Код ФИО полагаем пятизначным и положительным, следовательно он должен находится в диапазоне от 0 до 99999
      ReportError1(FileName,i,2,0,99999);										//если он не соответствует данному диапазону, то выводим сообщение об ошибке
	if (((*Dire)[i].Birthday < 19000101) || ((*Dire)[i].Birthday > 20202004))	//Дата рождения представлена в файлах в формате ГГГГДДММ. Положим, что минимальная дата рождения - 1 января 1900 года
		ReportError1(FileName, i, 3, 19000101, 20200420);						//максимальная - 20 апреля 2020 года. Таким образом, за пределы года число выйти не сможет
	if (((*Dire)[i].Birthday % 100 < 1) || ((*Dire)[i].Birthday % 100 > 12))	//но месяц и день могут принимать только определенные значения. Опустим февраль, февраль високосного года, и четные и нечетные месяцы
	{																			//тогда месяц должен быть в промежутке от 1 до 12
		FatalError = 1;
		sprintf(Sr, "Файл %s:В дате рождения элемента № %d допущена ошибка в месяце рождения\n", FileName, i);		//%100 - это получение остатка от деления. Если число с форматом ГГГГДДММ разделить на 100
		fwrite(Sr, sizeof(string80), 1, FileError);																	//и взять остаток от деления, мы получим только ММ - то есть месяц
	}
	if ((((*Dire)[i].Birthday / 100) % 100 < 1) || (((*Dire)[i].Birthday / 100) % 100 > 31))				//а день от 1 до 31
	{																										//чтобы выделить день в формате ГГГГДДММ мы сперва разделим его на 100 без остатка: ГГГГДДММ/100
		FatalError = 1;																						//тогда формат превратится в ГГГГДД, к которому снова применяем %100 и выделяем таким образом ДД - день
		sprintf(Sr, "Файл %s:В дате рождения элемента № %d допущена ошибка в дне рождения\n", FileName, i);
		fwrite(Sr, sizeof(string80), 1, FileError);
	}
	if (((*Dire)[i].House < 1) || ((*Dire)[i].House > 300))
			ReportError1(FileName, i, 5, 1, 300);
	if (((*Dire)[i].Flat < 1) || ((*Dire)[i].Flat > 400))				//номер дома и квартиры оставляем в диапазоне от 1 до 300-400
			ReportError1(FileName, i, 6, 1, 400);
	if (((*Dire)[i].Phone < 0) || ((*Dire)[i].Phone > 9999999))			//номер телефона это семизначное целое значение, причем 0 обозначает отсутствие телефона. от 0 до 9999999
			ReportError1(FileName, i, 7, 0, 9999999);    
	}
}  

void CheckKodifDiapason()
{
	int i;													//в файле кодификаторе только одно численное значение - код ФИО
  for (i=0; i<nk; i++)
		if ((Kodifs[i].Code<0) || (Kodifs[i].Code>99999))	//который совпадает с кодом в файлах input и add
		{
			FatalError=1;
			sprintf(Sr,
				"Файл Kodif.txt: в строке %d элемент 1 "
				"вне пределов 0..100\n",i+1);
		  fwrite(Sr,sizeof(string80),1,FileError);
		}
}    

void KodifParameters()
{          
int  i,j,Kod;				//заводим индексные переменные i, j
  for (i=0; i<nk-1; i++)
	{
    Kod=Kodifs[i].Code;
    for (j=i+1; j<nk; j++)
      if (Kod==Kodifs[j].Code)												//организовывем внешний и внутренний циклы, в которых перебираем все элементы кодификатора
			{																//и сравниваем их друг с другом. если находится одинаковый код - выдаем ошибку
        FatalError=1;
				sprintf(Sr,
"Файл Kodif.txt: равные значения Code в строках %d и %d (%d)\n",
				i+1,j+1,Kod);
				fwrite(Sr,sizeof(string80),1,FileError);
			}
	}
} 

void DireParameters(DirectoryAr *Dire, int n, char *FileName)
{     
	
int  i,j,k,Kod,Cond;
char Meas[5];

  for (i=0; i<n-1; i++)
	{
    Kod=(*Dire)[i].Code;
    for (j=i+1; j<n; j++)
      if (Kod==(*Dire)[j].Code)
			{															//аналогично кодификатору, в файлах input и add производим сравнение кодов 
        FatalError=1;													//при обнаружении одинаковых кодов, печатаем ошибку
				sprintf(Sr,
	"Файл %s : равные значения Code в строках %d и %d (%d)\n",
					FileName,i+1,j+1,Kod);
				fwrite(Sr,sizeof(string80),1,FileError);
			}
	}


  for (i=0; i<n; i++)
	{
    Kod=(*Dire)[i].Code;
    k=SearchKodif(Kod,nk);												//организовывем цикл, в котором просматриваем каждый элемент input и add
    if (k==-1)															//для каждого элемента вызываем функцию SearcjKodif, которая ищет соответствующий код в кодификаторе
		{	
      FatalError=1;
			sprintf(Sr,
"Файл %s : код ФИО %d (строка %d) отсутствует в кодификаторе\n",	//если для какой-либо записи отсутствует подходящий код, выводим сообщение об ошибке
					FileName,Kod,i+1);
			fwrite(Sr,sizeof(string80),1,FileError);
		}
	}
} 

void ReportError1(char *FileName, int i, int k, int d1,int d2)
{
  FatalError=1;																//функция исходя из переданных параметров формирует строку для печати об ошибке диапазона числа
	sprintf(Sr,
		"Файл %s : в строке %d элемент %d  вне пределов %d .. %d\n",
		FileName,i+1,k,d1,d2);
  fwrite(Sr,sizeof(string80),1,FileError);

} 

void ReadFileError()
{             
	char i=1;												//определяем переменную для считывания файла ошибок
  rewind(FileError);										//функция rewind перемещает указатель на начало файла. Т.к. в этом модуле постоянно происходит вывод сообщений в файл ошибок, для его
															//корректного просмотра необходимо перейти к его началу
	while (i!=EOF)											//i заранее положен как 1, т.к. в любом случае какая-то запись в файле ошибок была создана
	{
			i=fread(Sr,sizeof(string80),1,FileError);		//считываем строку из файла ошибок в строку Sr
			if (i<1) i = EOF;								//если ничего считать не удалось, помечаем i как EOF
			else printf("%s",Sr);							//иначе - печатаем строку из файла ошибок в консоль
	}
	wait_press_key("\nДля продолжения нажмите любую клавишу\n");	//перед выходом из функции ожидаем нажатия клавиши
}	

